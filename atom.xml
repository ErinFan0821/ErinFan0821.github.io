<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Erin Fan's Blog]]></title>
  <link href="http://ErinFan0821.github.io/atom.xml" rel="self"/>
  <link href="http://ErinFan0821.github.io/"/>
  <updated>2014-06-08T23:06:58+08:00</updated>
  <id>http://ErinFan0821.github.io/</id>
  <author>
    <name><![CDATA[Erin Fan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Jstl Core和fmt标签的使用]]></title>
    <link href="http://ErinFan0821.github.io/blog/2014/06/08/jstl-corehe-fmtbiao-qian-de-shi-yong/"/>
    <updated>2014-06-08T17:49:45+08:00</updated>
    <id>http://ErinFan0821.github.io/blog/2014/06/08/jstl-corehe-fmtbiao-qian-de-shi-yong</id>
    <content type="html"><![CDATA[<ol>
<li><p>什么是JSTL?</p>

<p>JSP标准标记库(JSP Standard Tag Library, JSTL)是一个实现Web应用程序中常见的通用功能的定制标记库集，这些功能包括迭代和条件判断，书库管理格式化，XML操作以及数据库的访问。</p></li>
<li><p>JSTL帮我们解决了什么问题？</p>

<p>JSTL帮组我们把底层内容模型与表示进行了分离。
在多数大型开发工程中，程序员负责实现后端，表示则留给一名或多名 Web 页面设计人员去做。在引入 JavaServer Pages（JSP）规范的版本 1.1 中的定制标记库之前，必须使用 JSP 脚本元素来在 JSP 页面内提供任意的定制功能性。显式地使用脚本元素违背了模型与表示相分离的原则。显式地使用脚本元素还要求，如果 Web 页面设计人员要做任何“从 JavaBean 组件中检索属性”之外的事情，他就要具有 Java 编程经验。这引起了人们对 JSP 页面内脚本元素的使用的广泛关注，这也就是JSTL存在的目的，我们的web开发人员不需要有java编程经验也可以写前端代码。</p></li>
<li><p>JSTL标签库有哪些？</p>

<p>在第一点里面说过JSTL是实现常见功能的定制标记库集，这些功能包括迭代和条件判断，书库管理格式化，XML操作以及数据库的访问。JSTL1.0 发布了四个定制标记库（core、format、xml 和 sql）和一堆通用标记库验证器（ScriptFreeTLV 和 PermittedTaglibsTLV）。 四个定制标记库的作用分别是： 1. core标记库提供了定制操作，通过限制了作用域的变量管理数据，以及执行页面内容的迭代和条件操作。它还提供了用来生成和操作URL的标记。2. format标记库定义了用来格式化数据（特别是数字和日期）的操作。它还支持使用本地化资源束来进行JSP页面的国际化。3. xml库包含一些标记，这些标记用来操作通过xml表示的数据。4. sql库定义了用来查询关系数据库的操作。两个JSTL标记库验证器允许开发人员在其jsp应用程序中强制的使用标准编码。1. 通过配置ScripFreeTLV验证器可以在JSP页面中禁用各种类型的JSP脚本元素&mdash;scriptlet,表达式和声明。 2. PermittedTaglibsTLV 验证器可以用来限制可能由应用程序的jsp页面访问的定制标记库集(包括JSTL标记库)。
以上是对jstl标记里面包含的内容做简单的介绍，由于在项目开发过程中使用较多的是core和fmt，所以这里的demo主要是core和fmt.</p></li>
<li><p>JSTL Demo</p>

<p>我在这是使用了spring MVC来搭建了一个简单的项目来做页面的demo，可以看一下我的目录结构。</p>

<p><img src="http://ErinFan0821.github.io/images/dd.png" width="400" height="400"></p></li>
</ol>


<p>其中jstlTestPage.jsp是用来demo显示的页面
jstlLearningController里面可以构造一些java对象，通过Modle来往jsp页面传值。
整个项目通过gradle来构建，jetty来部署。</p>

<p>这个demo里面我们主要关注jsp页面。</p>

<p>4.1 JSTL core 标签Demo(JSTL c)
   想要使用jstl需要在我们的工程文件里面引入相应的包, 我在这使用的是1.2的版本： jstl-1.2.jar。
   想要使用core标签，还需要在这个jsp页面加入：</p>

<p>   &lt;%@ taglib prefix=&ldquo;c&rdquo; uri=&ldquo;<a href="http://java.sun.com/jsp/jstl/core">http://java.sun.com/jsp/jstl/core</a>&rdquo; %></p>

<p>   1> c:out 用于显示数据对象（字符串、表达式）的内容或结果</p>

<p>   使用java脚本的方式为: &lt;% out.println(&ldquo;hello&rdquo;) %> &lt;% =表达式>
   使用JSTL标签: &lt;c:out value=&ldquo;字符串&rdquo;></p>

<p>   JSP页面代码：</p>

<pre><code>&lt;c:out value="I am a nomal string" default="defaultValue"&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value="I am a string with special char: &amp;lt&amp;lt&amp;lt&amp;lt" escapeXml="true"&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value="I am a string with special char: &amp;lt&amp;lt&amp;lt&amp;lt"&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:out value="I am a string with special char: &amp;lt&amp;lt&amp;lt&amp;lt" escapeXml="false"&gt;&lt;、c:out&gt;&lt;br&gt;
&lt;c:out value="${null}"&gt;default string&lt;/c:out&gt;
</code></pre>

<p>   第1行代码也等同于&lt;c:out value=&ldquo;I am a nomal string&rdquo;>defaultValue&lt;/c:out><br>
   value：表示要输出的值，
   default：表示如果value为null，则输出defaultValue, 参考第5行代码。
   第2，3，4行主要目的是显示escapeXml的用途，表示是否转换特殊字符，为true不转换，为false则转换，默认值是true.
   下面是页面输出的样子：</p>

<p>   <img src="http://ErinFan0821.github.io/images/cout.png" width="500" height="600"></p>

<p>   2> c:set 用于保存数据。</p>

<pre><code>&lt;c:set value="ErinFan" var="myName" scope="session"/&gt;
&lt;c:set var="name2" scope="session"&gt;Reg&lt;/c:set&gt;
&lt;c:set var="name2" scope="request"&gt;Reg&lt;/c:set&gt;
&lt;li&gt;get name from session: ${sessionScope.myName}&lt;/li&gt;
&lt;li&gt;get second name from the session: ${sessionScope.name2}&lt;/li&gt;
</code></pre>

<p>   value: 要被存储的值
   var: value存入的变量的名字
   scope:var变量的jsp范围，在这里为session, 另外还有application, page.</p>

<p>   页面：</p>

<p>   <img src="http://ErinFan0821.github.io/images/cset.png" width="500" height="600"></p>

<p>   3> c:remove 用来移除范围变量</p>

<pre><code>&lt;c:out value="c:remove demo"/&gt;&lt;br&gt;
&lt;c:remove var="name2" scope="session"/&gt;
&lt;c:out value="${sessionScope.name2}"&gt;name2 already been removed from session&lt;/c:out&gt;&lt;br&gt;
</code></pre>

<p>   可以看到name2已经被移除，所以会输出default值</p>

<p>   <img src="http://ErinFan0821.github.io/images/cremove.png" width="500" height="600"></p>

<p>   4> c:catch 用来捕获嵌套在这个标签里面的操作所抛出来的异常对象，并将异常信息保存到变量中。</p>

<p>   5> c:if 用于实现java中的if语句的功能</p>

<pre><code>&lt;c:set value="10000" var="account1"/&gt;
&lt;c:set value="20000" var="account2"/&gt;
&lt;c:if test="${account1 == '10000'}" var="account1TestResult"&gt;&lt;/c:if&gt;
&lt;c:out value="account1 test value is: ${account1TestResult}"&gt;&lt;/c:out&gt;&lt;br&gt;
&lt;c:if test="${account2 == '10000'}" var="account2TestResult"&gt;&lt;/c:if&gt;
&lt;c:out value="account2 test value is: ${account2TestResult}"&gt;&lt;/c:out&gt;&lt;br&gt;
</code></pre>

<p>   第1，2句设置了两个变量account1, account2, 第3句用if做了判断，判断的结果放入变量account1TestResult里，第4句把上面判断的结果输出页面，第5句和第6句也是判断和输出，这个和java代码很像，应该很容易看懂。</p>

<p>   <img src="http://ErinFan0821.github.io/images/cif.png" width="400" height="500"></p>

<p>   6> c:choose  和 &lt;c:when> 、 &lt;c:otherwise> 一起实现互斥条件执行，类似于 java 中的 if else.
&lt;c:choose> 一般作为 &lt;c:when> 、 &lt;c:otherwise> 的父标签。</p>

<pre><code>&lt;c:set var="scope" value="90"&gt;&lt;/c:set&gt;
&lt;c:choose&gt;
    &lt;c:when test="${scope &gt;= 90}"&gt;
        Congratulations!
    &lt;/c:when&gt;
    &lt;c:when test="${scope &gt;= 80 &amp;&amp; scope &lt; 90}"&gt;
        Just So So!
    &lt;/c:when&gt;
    &lt;c:when test="${scope &gt;= 70 &amp;&amp; scope &lt; 80}"&gt;
        Need more hard work!
    &lt;/c:when&gt;
    &lt;c:otherwise&gt;
        Sorry, you do not pass the exam.
    &lt;/c:otherwise&gt;
&lt;/c:choose&gt;
</code></pre>

<p>   第一句话设置了scope变量值为90，然后进入choose里面去做判断。最后输出结果如下图：</p>

<p>   <img src="http://ErinFan0821.github.io/images/cchoose.png" width="500" height="600"></p>

<p>   7> c:forEach 迭代标签</p>

<pre><code>&lt;c:forEach var="account" items="${accountList}"&gt;
    &lt;c:out value="${account}"/&gt;
&lt;/c:forEach&gt;
&lt;br&gt;&lt;br&gt;
&lt;c:out value="Use begin and end to do foreach"/&gt;&lt;br&gt;
&lt;c:forEach var="account" items="${accountList}" begin="1" end="2" step="1"&gt;
    &lt;c:out value="${account}"/&gt;
&lt;/c:forEach&gt;
</code></pre>

<p>   forEach可以使用两种不同的写法，第一个forEach就是第一种，默认的会从头到尾挨个循环输出。
   第二个foreach是使用了begin，end, step属性，begin表示开始循环的位置，end表示结束循环的位置， step表示循环一次跳跃多少个index.
   这两个的输出如下图：</p>

<p>   <img src="http://ErinFan0821.github.io/images/cforeach1.png" width="300" height="400"></p>

<p>   c:foreach标签里面有个属性varStatus，用来表示当前foreach的状态，可以看下下面的例子：</p>

<pre><code>&lt;c:forEach var="account" items="${accountList}" begin="0" end="3" step="2" varStatus="attribute"&gt;
    &lt;br&gt;
    Current value: &lt;c:out value="${account}"/&gt;&lt;br&gt;
    Current Index: &lt;c:out value="${attribute.index}"/&gt;&lt;br&gt;
    Foreach times: &lt;c:out value="${attribute.count}"/&gt;&lt;br&gt;
    Is the first index: &lt;c:out value="${attribute.first}"/&gt;&lt;br&gt;
    Is the last index: &lt;c:out value="${attribute.last}"/&gt;&lt;br&gt;
&lt;/c:forEach&gt;
</code></pre>

<p>   这个循环开始的位置是0，结束的位子是3，一次跳2步，varStatus变量名字为attribute,用这个变量名就可以调用这个属性的值：index表示当前循环的index; count表示当前循环是第几次循环; first表示当前循环是否是第一次，如果不是返回false,是返回true; last表示的意思和first正好相反，表示判断当前循环是否是最后一次。
页面输入如下图：</p>

<p>   <img src="http://ErinFan0821.github.io/images/cforeach2.png" width="300" height="400"></p>

<p>   8> c:forTokens 用于对带有相同符合格式内容进行分割输出，例如var = &ldquo;1,2,3,4&rdquo;, 以逗号为分隔</p>

<pre><code>&lt;c:forTokens items="1,2,3,4" delims="," var="result"&gt;
    &lt;c:out value="${result}"/&gt;
&lt;/c:forTokens&gt;
&lt;br&gt;
&lt;c:forTokens items="A#B#C" delims="#" var="result" varStatus="attribute"&gt;&lt;br&gt;
    Current Token: &lt;c:out value="${result}"/&gt;&lt;br&gt;
    Current Index: &lt;c:out value="${attribute.index}"/&gt;&lt;br&gt;
    Foreach Times: &lt;c:out value="${attribute.count}"/&gt;&lt;br&gt;
    Is the first index: &lt;c:out value="${attribute.first}"/&gt;&lt;br&gt;
    Is the last index: &lt;c:out value="${attribute.last}"/&gt;&lt;br&gt;
&lt;/c:forTokens&gt;
</code></pre>

<p>   items表示被循环遍历的对象，一般为数组和集合类
   delims表示分隔符
   这里也有begin,end,step用来控制位置和循环步长的属性。
   varStatus表示迭代当前的状态。</p>

<p>   输出如图：</p>

<p>   <img src="http://ErinFan0821.github.io/images/cfortokens.png" width="300" height="400"></p>

<p>   9> c:import 把其他静态或者动态文件包含到jsp页面，可以包含其他web应用中的文件，甚至是网络上的资源。</p>

<pre><code>&lt;c:out value="c:import demo"/&gt;&lt;br&gt;
&lt;c:catch var="error"&gt;
    &lt;c:import url="http://sdfsadfaf"/&gt;
&lt;/c:catch&gt;
&lt;c:out value="${error}"/&gt;&lt;br&gt;
</code></pre>

<p>   这里可以看到c:catch的用法，如果页面没法打开，会抛出异常，最后一句话用于输出异常信息，页面如下图：</p>

<p>   <img src="http://ErinFan0821.github.io/images/ccatch.png" width="300" height="400"></p>

<p>   如果url正确，则会打开url，如下面直接就打开了百度的页面。</p>

<pre><code>&lt;c:out value="c:import demo"/&gt;&lt;br&gt;
&lt;c:catch var="error"&gt;
    &lt;c:import url="http://www.baidu.com"/&gt;
&lt;/c:catch&gt;
&lt;c:out value="${error}"/&gt;&lt;br&gt;
</code></pre>

<p>   c:import还可以通过本地的url打开相应的文件：</p>

<pre><code>&lt;c:catch var="error"&gt;
    First import: &lt;c:import url="test.txt"/&gt;
&lt;/c:catch&gt;
&lt;c:out value="${error}"/&gt;&lt;br&gt;
&lt;c:catch var="error"&gt;
    &lt;c:import url="test.txt" var="myurl" scope="session" charEncoding="gbk"/&gt;&lt;br&gt;
    Second import: &lt;c:out value="${myurl}"/&gt;
&lt;/c:catch&gt;
</code></pre>

<p>   test.txt是我放在和当前jsp同一目录下的文件，通过上面的代码，直接就帮我把这个文件里面的内容输出到页面上来了，也有两种不同的输入方式，可以放到变量里面，也可是直接输出。如下图：</p>

<p>   <img src="http://ErinFan0821.github.io/images/cimport.png" width="300" height="400"></p>

<p>   10> c:redirect 该标签用来实现请求的重定向。例如，对用户输入的用户名和密码进行验证，不成功则重定向到登录页面。或者实现Web应用不同模块之间的衔接</p>

<pre><code>&lt;c:out value="c:redirect demo"/&gt;&lt;br&gt;
&lt;c:redirect url="http://localhost:8080"&gt;
    &lt;c:param name="username" value="fakeUser"/&gt;
    &lt;c:param name="password" value="fakePsw"/&gt;
&lt;/c:redirect&gt;
</code></pre>

<p>   上面这段代码运行后悔跳转为： <a href="http://localhost:8080/?username=fakeUser&amp;password=fakePsw">http://localhost:8080/?username=fakeUser&amp;password=fakePsw</a></p>

<p>   11> c:url 用于动态生成一个 String 类型的URL，可以同上个标签共同使用，也可以使用HTML的a标签实现超链接</p>

<pre><code>&lt;c:url value="http://localhost:8080/jstlLearning" var="url" scope="session"/&gt;
&lt;a href="${url}"&gt;Open Url&lt;/a&gt;&lt;br&gt;
</code></pre>

<p>   页面显示如下，点击Open Url会跳转到<a href="http://localhost:8080/jstlLearning%E9%A1%B5%E9%9D%A2">http://localhost:8080/jstlLearning%E9%A1%B5%E9%9D%A2</a></p>

<p>   <img src="http://ErinFan0821.github.io/images/openurl.png" width="300" height="400"></p>

<p>4.2  JSTL format标签demo(JSTL fmt)
   fmt标签主要就是用来格式化。
   1> fmt:formatDate value表示要格式化的值， pattern表示要格式化的格式</p>

<pre><code>&lt;fmt:formatDate value="${date}" pattern="yyyy-MM-dd HH:mm:ss"/&gt;&lt;br&gt;
</code></pre>

<p>   2> fmt:formatNumber 有三种格式化的type，number(数字), percent(百分比), currency(货币)</p>

<pre><code>&lt;fmt:formatNumber value="145.65464546" pattern="0.00"/&gt;&lt;br&gt;
&lt;fmt:formatNumber type="number" value="4534353.45353"/&gt;&lt;br&gt;
&lt;fmt:formatNumber type="percent" value="0.6789"/&gt;&lt;br&gt;
</code></pre>

<p>   <img src="http://ErinFan0821.github.io/images/fmt.png" width="300" height="400"></p>

<p>   在这里面其实还用了jsp EL(Expression Language).
   表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法。它是一种简单的语言，基于可用的命名空间（PageContext 属性）、嵌套属性和对集合、操作符（算术型、关系型和逻辑型）的访问符、映射到 Java 类中静态方法的可扩展函数以及一组隐式对象。EL 提供了在 JSP 脚本编制元素范围外使用运行时表达式的功能。脚本编制元素是指页面中能够用于在 JSP 文件中嵌入 Java 代码的元素。它们通常用于对象操作以及执行那些影响所生成内容的计算。JSP 2.0 将 EL 表达式添加为一种脚本编制元素。
   我们上面的demo中类似${expression}这样的表达就是使用的EL，将会在下一篇博客中详细的介绍。</p>

<p>   本文章参考url:</p>

<p>   <a href="http://www.ibm.com/developerworks/cn/java/j-jsptags/">http://www.ibm.com/developerworks/cn/java/j-jsptags/</a></p>

<p>   <a href="http://www.cnblogs.com/cliffever/archive/2008/11/13/1333025.html">http://www.cnblogs.com/cliffever/archive/2008/11/13/1333025.html</a></p>

<p>   <a href="http://elf8848.iteye.com/blog/245559">http://elf8848.iteye.com/blog/245559</a></p>

<p>   源码下载地址：</p>

<p>   <a href="https://github.com/ErinFan0821/jstlLearning.git">https://github.com/ErinFan0821/jstlLearning.git</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web Service in Spring Demo]]></title>
    <link href="http://ErinFan0821.github.io/blog/2014/06/03/web-service-in-spring-demo/"/>
    <updated>2014-06-03T23:08:21+08:00</updated>
    <id>http://ErinFan0821.github.io/blog/2014/06/03/web-service-in-spring-demo</id>
    <content type="html"><![CDATA[<ol>
<li><p>什么是webService?</p>

<p>Web Service技术存在的价值是：可以使运行在不同机器上的不同应用无需借助附加的，专门的第三方软件或硬件就可以相互交换数据或集成。在web Service架构中，存在着客户端，服务端。服务端通过Web Service描述语言(WSDL)来把自己提供什么样的服务发布出来，客户端通过这个wsdl就可以知道服务端提供了什么样的服务，就可以向服务端发request，服务端返回response来完成一次交互。</p></li>
<li><p>什么是WSDL?为什么要存在WSDL?</p>

<p>假如你写了一个Service, 那么你怎么向别人介绍说你的Service有什么功能，以及每个函数调用时的参数是什么呢？两种方式： 写文档，口头告诉使用的的service的人。但是，当使用这个service的人真正开始想要去调用你的服务的时候，他们使用的开发工具没法帮助开发人员快速的构建出来他们要访问的服务的代码。那么怎么办呢？这就需要一个正式的描述性文档，机器能够阅读，人也能够阅读的文档。 Web Service描述语言（Web Service Description Language）WSDL 就指这样一个基于XML的语言，用于描述Web Service及其函数，参数和返回值。机器可以直接根据WSDL生成相应的克调用的Web Service代码。</p></li>
<li><p>客户端和服务端通过什么来进行消息的传递？</p>

<p>SOAP(Simple Object Access Protocol)简单对象访问协议，它使用应用层协议作为其传输协议，大多数情况下是使用http来协助传输，也就是说，客户端发送的请求被转成soap格式之后，通过http来进行传输。它也是基于XML的。
大致了解了webService之后，可以试着去实现一个简单的webService, 包括服务端，客户端，以及服务端暴露出来的wsdl. 我们不需要去专门的写一个wsdl, 可以XSD（XML Schema Definition) 来描述我们的服务, client只要能拿到这个xsd便可知道服务端的服务长什么样子。</p></li>
</ol>


<p>接下来是代码实现，可以分五步走：
Step1:写描述我们服务的XSD。
Step2:通过jaxb框架把xsd转化成相应的java domain类。（服务端和客户端都需要做这个事情）
Step3:Server端写Endpoint来提供相应的服务。
Step4:动态生成wsdl, 可在soap ui里面测试写的server是否正确，
Step5:写client端代码，去调用之前写的server</p>

<p>Server 和 Client 应该放在两个不同的工程下面，先看看Server工程的目录结构：</p>

<p><img src="http://ErinFan0821.github.io/images/d.png" width="300" height="300"></p>

<p>看起来还是比较的清晰，我是把xsd直接放在webapp这个目录下的，spring-ws-servlet.xml和web.xml是我的配置文件</p>

<p>Step1: 写描述我们服务的XSD。在这里是AccountDetail.xsd, 可以看看代码：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
       targetNamespace="http://erinfan.webservices.com"
       xmlns="http://erinfan.webservices.com"
       elementFormDefault="qualified"
       attributeFormDefault="unqualified"&gt;
&lt;xs:element name="Account" type="Account"/&gt;
&lt;xs:complexType name="Account"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="AccountName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

&lt;xs:element name="AccountDetailsRequest"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="accountName" type="xs:string" /&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="AccountDetailsResponse"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="AccountDetails" type="Account"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
&lt;/xs:schema&gt;
</code></pre>

<p>这里面需要看的几个地方：</p>

<p>1) xmlns:xs=&ldquo;<a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a>&rdquo; 这里我们使用了标准的命名空间(xs), 和这个命名空间相关联的URI是Schema的语言定义，其标准值是<a href="http://www.w3.org/2001/XMLSchema,">http://www.w3.org/2001/XMLSchema,</a> 换句话说，下面所使用的schema的默认的元素如element, sequence, type这些都是来自这个标准。</p>

<p>2) targetNamespace=&ldquo;<a href="http://erinfan.webservices.com">http://erinfan.webservices.com</a>&rdquo; 这句话是指我们下面自己定义的一些类型是来自于这个命名空间。</p>

<p>3)  &lt;xs:element name=&ldquo;Account&rdquo; type=&ldquo;Account&rdquo;/> 定义了一个名字为Account的type，对应到我们的代码里面就是一个java domain类Account</p>

<p>4)</p>

<pre><code>&lt;xs:complexType name="Account"&gt;
    &lt;xs:sequence&gt;
        &lt;xs:element name="AccountName" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</code></pre>

<p> 这里定义了Account里面有类型为string的属性accountName</p>

<p> 5)</p>

<pre><code>&lt;xs:element name="AccountDetailsRequest"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="accountName" type="xs:string" /&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="AccountDetailsResponse"&gt;
    &lt;xs:complexType&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="AccountDetails" type="Account"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre>

<p> 第一个element描述了我们的server可以接收的request的name，AccountDetailRequest也可以理解为我们的请求的根标记。另外里面还描述了request里面可以传的值，在这是一个string类型的值。</p>

<p> 第二个element描述了我们的server会返回的的response的name，以及返回来的类型，在这是把Account类型的对象返回来。</p>

<p>Step2: 通过jaxb框架把xsd转化成相应的java domain类。
我在这是直接使用的intellij里面的jaxb插件来转换的,也还有其他的办法，比如用gradle.</p>

<p>Step3:Server端写Endpoint来提供相应的服务。</p>

<pre><code> @Endpoint
public class AccountServiceEndpoint {
    private static final String TARGET_NAMESPACE = "http://erinfan.webservices.com";

    @PayloadRoot(localPart = "AccountDetailsRequest", namespace = TARGET_NAMESPACE)
    public
    @ResponsePayload
    AccountDetailsResponse getAccountDetails(@RequestPayload AccountDetailsRequest request) {
        AccountDetailsResponse response = new AccountDetailsResponse();
        Account account = new Account();
        account.setAccountName(request.getAccountName());
        response.setAccountDetails(account);
        return response;

    }
}
</code></pre>

<p>注解@Endpoint是spring提供的，用来表示这是一个server端的endpoint，我们只需要在配置文件里面加上自动扫描的配置，spring就可以帮我们找到这个endpoint来处理client端发过来的请求，这就是使用spring框架的好处，很多东西它都帮你处理了，只需要一个简单的注解便可。</p>

<p>注解@PayloadRoot(localPart = &ldquo;AccountDetailsRequest&rdquo;, namespace = TARGET_NAMESPACE) 这个注解表示只要发过来的request满足这两个条件，便交给getAccountDetails()这个函数来处理，其中localPart里面的值需要与client端请求文件里面的根标记一致。namespace需要与Client端请求文件里面的targetNamespace一致.</p>

<p>注解@ResponsePayload和注解@RequestPayload 用来引入响应和请求的对象，也就是我们通过jaxb解析出来的两个对象AccountDetailsResponse和AccountDetailsRequest
实现部分的代码还是比较简单，把request里传递过来的accountName设置进入到new出来的Account对象里面，然后把这个对象set到response，返回response. Client端那边获取到的response就是一个包含着accountName的Account对象。</p>

<p>写完了Endpoint了，服务端的事情并没有结束，接下来是配置，需要配置什么呢？</p>

<p>第一是配置spring, 之前在endpoint里面写了注解@Endpoint, spring怎么去识别这个注解的呢？这就需要我们在spring-ws-servlet.xml这个文件里面去配置。</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:context="http://www.springframework.org/schema/context"
   xmlns:sws="http://www.springframework.org/schema/web-services"
   xsi:schemaLocation="http://www.springframework.org/schema/beans
                       http://www.springframework.org/schema/beans/spring-beans.xsd
                       http://www.springframework.org/schema/context
                       http://www.springframework.org/schema/context/spring-context.xsd
                       http://www.springframework.org/schema/web-services
                       http://www.springframework.org/schema/web-services/web-services.xsd"&gt;

&lt;context:component-scan base-package="com.erinfan"/&gt;
&lt;sws:annotation-driven/&gt;

&lt;sws:dynamic-wsdl id="account" portTypeName="Account"
                  locationUri="http://localhost:8080/webServiceAccount/accountService"&gt;
    &lt;sws:xsd location="AccountDetails.xsd"/&gt;
&lt;/sws:dynamic-wsdl&gt;

&lt;/beans&gt;
</code></pre>

<p> 其中</p>

<pre><code>&lt;context:component-scan base-package="com.erinfan"/&gt;
&lt;sws:annotation-driven/&gt;
</code></pre>

<p> 就是添加 spring的自动扫描annotation，扫描的目标是com.erinfan，也就是我的工程里面的package。</p>

<pre><code> &lt;sws:dynamic-wsdl id="account" portTypeName="Account"
                  locationUri="http://localhost:8080/webServiceAccount/accountService"&gt;
    &lt;sws:xsd location="AccountDetails.xsd"/&gt;
&lt;/sws:dynamic-wsdl&gt;
</code></pre>

<p>而这段话是方便生成wsdl而添加的，只需要在浏览器里面输入<a href="http://localhost:8080/webServiceAccount/accountService/account.wsdl">http://localhost:8080/webServiceAccount/accountService/account.wsdl</a> 便可得到通过AccountDetails.xsd转换出来的wsdl.这个wsdl之所以要生成，是为了能够使用soap ui来测试server是否work.</p>

<p>除了配置spring外，还需把spring-ws-servlet配置到web.xml里面。</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.4"
     xmlns="http://java.sun.com/xml/ns/j2ee"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee
     http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;

&lt;servlet&gt;
    &lt;servlet-name&gt;spring-ws&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.ws.transport.http.MessageDispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;transformWsdlLocations&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;spring-ws&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>

<p>Step4: 动态生成wsdl, 可在soap ui里面测试写的server是否正确，</p>

<p>把第三步中生成的wsdl导入到soap ui里面，在soap ui自动生成的soap request里面填入参数，便可以发消息了，如果写的server没有问题，便会给返回相应的response.</p>

<p>Step5: 写client端代码，去调用之前写的server。</p>

<p>这里面需要做三件事，第一是导入server端提供的AccountDetail.xsd, 然后通过jaxb生成相应的java domain类。 第二是写client端代码来调用server. 第三是配置applicationContext.xml。
工程目录如下图：</p>

<p><img src="http://ErinFan0821.github.io/images/clientD.png" width="300" height="300"></p>

<p>第一步很简单，不再累赘，看server里面怎么整的便可。</p>

<p>第二步可以看看代码先：</p>

<pre><code>package com.erinfan.client;

import com.erinfan.domain.AccountDetailsRequest;
import com.erinfan.domain.AccountDetailsResponse;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.FileSystemXmlApplicationContext;
import org.springframework.ws.client.core.WebServiceTemplate;

public class AccountClient {
    public static void main(String[] args) {
        ApplicationContext context = new FileSystemXmlApplicationContext("classpath:applicationContext.xml");
        WebServiceTemplate webServiceTemplate = (WebServiceTemplate) context.getBean("webServiceTemplate");
        AccountDetailsRequest request = new AccountDetailsRequest();
        request.setAccountName("ErinFan");
        AccountDetailsResponse response = (AccountDetailsResponse) webServiceTemplate.marshalSendAndReceive(request);

        System.out.println(response.getAccountDetails().getAccountName());
    }
}
</code></pre>

<p>最主要的东西就是使用了spring提供的WebServiceTemplate去帮我们做了发消息和接收消息的工作，这又体现了框架的好处，帮我们做了封装，方便快捷，省去了很多麻烦.</p>

<p>想要使用WebServiceTemplate，就需要做相应的配置，也就是我们的第三步，配置applicationContext.xml,代码如下：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;

&lt;bean id="webServiceTemplate" class="org.springframework.ws.client.core.WebServiceTemplate"&gt;
    &lt;property name="defaultUri" value="http://localhost:8080/webServiceAccount/defaultUri"/&gt;
    &lt;property name="marshaller" ref="marshaller"/&gt;
    &lt;property name="unmarshaller" ref="unmarshaller"/&gt;

&lt;/bean&gt;

&lt;bean id="marshaller" class="org.springframework.oxm.jaxb.Jaxb2Marshaller"&gt;
    &lt;property name="classesToBeBound"&gt;
        &lt;list&gt;
            &lt;value&gt;com.erinfan.domain.AccountDetailsRequest&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="unmarshaller" class="org.springframework.oxm.jaxb.Jaxb2Marshaller"&gt;
    &lt;property name="classesToBeBound"&gt;
        &lt;list&gt;
            &lt;value&gt;com.erinfan.domain.AccountDetailsResponse&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>这里面主要的东西就是marshaller和unmarshaller了。
WebServiceTemplate 会帮我们把我们发出去的request做一个marshaller的工作，转换成soap消息发送出去。unmarshaller是将server端的soap response转换成我们在client端可识别和操作的对象.</p>

<p>到这里为止就完成了一个简单的spring web service的demo的全部代码工作了。</p>

<p>接下来只需要将服务部署，然后通过客户端去访问就可以了。我在这里使用的是jetty容器来部署我的服务，然后客户端直接运行main函数便可调用server。</p>

<p>源码下载地址：</p>

<p>服务端： <a href="https://github.com/ErinFan0821/webServiceAccount.git">https://github.com/ErinFan0821/webServiceAccount.git</a></p>

<p>客户端： <a href="https://github.com/ErinFan0821/webServiceAccountClient.git">https://github.com/ErinFan0821/webServiceAccountClient.git</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test]]></title>
    <link href="http://ErinFan0821.github.io/blog/2014/06/03/test/"/>
    <updated>2014-06-03T20:43:36+08:00</updated>
    <id>http://ErinFan0821.github.io/blog/2014/06/03/test</id>
    <content type="html"><![CDATA[<p>To be or not to be, is not just a choose but also a spirit.</p>
]]></content>
  </entry>
  
</feed>
